<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Animated Spider Web BG</title>

<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { width: 100%; height: 100%; }

  body {
    background: #000;
    overflow: hidden;
  }

  /* Canvas Background */
  #spiderWebCanvas {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    background:
      radial-gradient(1200px 600px at 10% 20%, rgba(255,215,0,0.02), transparent 10%),
      radial-gradient(900px 400px at 90% 80%, rgba(255,215,0,0.01), transparent 8%);
    mix-blend-mode: screen;
  }
</style>
</head>

<body>

<canvas id="spiderWebCanvas"></canvas>

<script>
(() => {
  const canvas = document.getElementById("spiderWebCanvas");
  const ctx = canvas.getContext("2d");

  let w, h;
  const NODE_COUNT = 85;
  const LINK_DIST = 140;
  const MOUSE_INFLUENCE = 140;

  const mouse = { x: 0, y: 0, active: false };
  const offset = { x: 0, y: 0 };
  let nodes = [];

  function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
    initNodes();
  }
  window.addEventListener("resize", resize);
  resize();

  function rand(min, max) {
    return Math.random() * (max - min) + min;
  }

  function initNodes() {
    nodes = [];
    for (let i = 0; i < NODE_COUNT; i++) {
      nodes.push({
        x: rand(0, w),
        y: rand(0, h),
        vx: rand(-0.25, 0.25),
        vy: rand(-0.25, 0.25),
        r: rand(0.8, 2.6),
        baseR: rand(0.8, 2.6),
        flick: Math.random() * Math.PI * 2
      });
    }
  }

  window.addEventListener("mousemove", e => {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
    mouse.active = true;
  });
  window.addEventListener("mouseleave", () => mouse.active = false);

  function updateOffset() {
    offset.x += ((mouse.x - w / 2) * 0.02 - offset.x) * 0.08;
    offset.y += ((mouse.y - h / 2) * 0.02 - offset.y) * 0.08;
  }

  function animate() {
    updateOffset();
    ctx.clearRect(0, 0, w, h);

    nodes.forEach(n => {
      n.x += n.vx + offset.x * 0.002;
      n.y += n.vy + offset.y * 0.002;

      if (mouse.active) {
        const dx = n.x - mouse.x;
        const dy = n.y - mouse.y;
        const d = Math.hypot(dx, dy);
        if (d < MOUSE_INFLUENCE && d > 0.1) {
          const f = (1 - d / MOUSE_INFLUENCE) * 0.6;
          n.vx += (dx / d) * f;
          n.vy += (dy / d) * f;
          n.r = n.baseR + 2 * (1 - d / MOUSE_INFLUENCE);
        } else {
          n.r += (n.baseR - n.r) * 0.05;
        }
      }

      if (n.x < 0 || n.x > w) n.vx *= -1;
      if (n.y < 0 || n.y > h) n.vy *= -1;
    });

    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const a = nodes[i], b = nodes[j];
        const d = Math.hypot(a.x - b.x, a.y - b.y);
        if (d < LINK_DIST) {
          const alpha = 1 - d / LINK_DIST;
          ctx.strokeStyle = `rgba(255,215,0,${0.06 * alpha})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(a.x + offset.x, a.y + offset.y);
          ctx.lineTo(b.x + offset.x, b.y + offset.y);
          ctx.stroke();
        }
      }
    }

    nodes.forEach(n => {
      ctx.fillStyle = "rgba(255,215,0,0.9)";
      ctx.beginPath();
      ctx.arc(n.x + offset.x, n.y + offset.y, n.r, 0, Math.PI * 2);
      ctx.fill();
    });

    requestAnimationFrame(animate);
  }

  animate();
})();
</script>

</body>
</html>
